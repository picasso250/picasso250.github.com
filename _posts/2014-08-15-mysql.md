---
title: 《高性能 MySQL》读书笔记
layout: post
---

- 一般情况下，应该尽量使用最小数据类型。
- 尽量避免NULL，最好指定列为NOT NULL。例外是InnoDB使用单独的bit存储NULL值，对稀疏数据有很好的空间效率。
- 如果定义表结构时没有指定为NOT NULL,默认都是允许NULL的。
- 整数：TINYINT 8, SMALLINT 16, MEDIUMINT 24, INT 32, BIGINT 64
- 整数的宽度如INT(11)对大多数客户端没有意义。对存储和计算来说，INT(1)和INT(20) 是相同的。

索引覆盖
---------

在查询的时候，如果数据全部可以从索引中读取，无需再取其他的行数据（避免了磁盘IO），那么无疑，速度将会飞快。

    select user_name from user where user_id=3;

如果有个索引 `(user_id,user_name)` 就可以做到索引覆盖。

file sort
----------

file sort 不可望文生义，并不是磁盘排序的意思。而是需要做额外的排序的意思。有的时候，这个额外排序是内部排序，在内存中完成，有的时候是外部排序，这个时候就是名副其实的 file sort 了。有没有不需要做额外的排序的呢？当然有。

    select user_name from user order by last_login_time desc;

假如有个索引 `(last_login_time desc)`，那么我们就不用 file sort 了。

假如有以下语句，要做到索引覆盖，我们需要什么索引呢？

    select user_name from user where group_id=3 order by last_login_time desc

答案是 `(group_id,last_login_time desc, user_name)`，你答对了吗？

B树
------

MySQL 中的绝大部分的索引，都是 B+Tree。所以，既可以快速查找某个值，又可以做排序。

- 全值匹配 `where a=3`
- 左前缀匹配 `where a like 'The big%'`
- 匹配范围值 `where a between 3 and 8`

另一种索引是 Hash 索引，这种索引只可以快速查找，不能用于排序。

一些 dont
--------------

    where id+1=5
    where to_days(curent_date) - to_days(create_time) <= 10
    

$\sum_{i=1}^n i$